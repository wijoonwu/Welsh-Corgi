
## Array

### 배열의 읽기

먼저, 메모리는 아래와 같이 휘발성/비휘발성 2가지 종류가 있다.

> **휘발성 메모리**  - 컴퓨터를 끄는 순간 모든 데이터가 사라짐. (ex.RAM)

> **비휘발성 메모리** - 컴퓨터를 껐다가 켜도 데이터가 그대로 존재함 (ex.하드 드라이브)

프로그램이 돌아가고, 변수를 생성할 때 데이터는 모두 휘발성 메모리인 RAM에 저장된다.
그리고 RAM은 데이터를 읽는 속도가 하드 드라이브 보다 빠르다.

메모리가 데이터가 들어있는 박스들을 모아둔 그룹이고 
0번째에 위치한 데이터 박스에서 5번째 데이터 박스로 이동해야한다고 할 때

하드 드라이브는 0, 1, 2 ... 5 순서대로만 접근을 할 수 있지만
RAM은 Random Access Memory라는 이름대로 데이터에 **랜덤으로** 
접근할 수 있어 0번 데이터에서 5번 데이터로 빠르게 이동하기 때문이다.

그래서 0부터 인덱스 번호를 가지는 배열은 길이와 관계 없이 인덱스에서 
요소를 읽어내는 속도는 동일하며 인덱스 번호만 알고 있다면 
배열이 5개든 100개든 랜덤하게 접근해 데이터를 빠르게 읽어내기 때문에 
많은 자료를 읽어야 할 수록 강점을 가진다.

### 배열의 검색
그런데 인덱스 번호를 몰라 내가 원하는 데이터를 검색해야 할 때에는 
모든 데이터 박스를 순서대로 일일히, 하나 하나 뒤져서 내가 원하는 
데이터가 나올 때까지 모두 확인해야하기 때문에 검색 속도는 빠르지 않다.

### 배열의 삽입
배열을 만들 때 메모리 공간을 미리 확보해야 하므로 배열은 크기가 이미 정해져있다.
길이가 5인 배열에 4만큼만 데이터가 들어있어서 공간이 남아있는 상태이기만 한다면
간단하게 남은 공간에 데이터를 삽입하면 좋게 끝날 것이다.

하지만 만약 중간, 혹은 맨 앞에 데이터를 삽입해야 한다면 
그 공간을 비우기 위해서 배열들이 다 한칸씩 옆으로 이동해야 한다.

또, 배열이 크기만큼 데이터가 가득 차있는 상태에서 데이터를 추가해야 한다면
배열은 선언 때 사이즈가 정해져있으므로 기존 배열을 복사해놓고, 
새 배열을 크기를 늘려 선언한 다음에 복사해둔 배열을 붙여넣기 해야하는 불편함이 있다.

### 배열의 삭제
배열의 삽입과 마찬가지로, 가장 끝에 있는 데이터를 삭제하고 싶다면 
간단하게도 그냥 삭제를 하면 된다.

그런데 배열의 가장 첫번째 혹은 중간에 있는 데이터를 삭제하고 싶다면
삭제 이후 배열을 한칸씩 이동시켜서 공백을 채워야한다.

## **Array 정리**
배열은 데이터를 읽을 땐 가장 빠르지만, 검색/삽입/삭제를 할 때에는 조금 느려진다. 데이터가 4~5개라면 괜찮지만 1,000개가 넘어간다고 생각하면 힘들 것이다.


## 🙏 Reference
- [노마드코더 유튜브 채널](https://www.youtube.com/playlist?list=PL7jH19IHhOLMdHvl3KBfFI70r9P0lkJwL)
